# SPDX-License-Identifier: AGPL-3.0-only WITH LICENSE-ADDITIONAL
# Copyright (C) 2025 Петунин Лев Михайлович

# Импорт необходимых модулей
from flask import Blueprint, jsonify  # Blueprint для создания модуля маршрутов, jsonify для формирования JSON-ответов
import logging  # Модуль для логирования

# Создаем логгер для текущего модуля
# __name__ автоматически подставляет имя текущего модуля (например, 'k8s.healthz')
# Это позволяет идентифицировать источник логов
logger = logging.getLogger(__name__)

# Создаем Blueprint (модуль маршрутов) для healthcheck-эндпоинтов
# Первый аргумент ('healthz') - имя Blueprint (используется Flask для внутренней маршрутизации)
# __name__ - имя модуля, где создается Blueprint (используется Flask для определения местоположения шаблонов)
healthz_bp = Blueprint('healthz', __name__)

# Декорируем функцию для обработки GET-запросов по пути '/healthz'
# Этот эндпоинт используется для проверки работоспособности сервиса (health check)
@healthz_bp.route('/healthz', methods=['GET'])
def healthz():
    # Записываем отладочное сообщение в лог
    # Уровень DEBUG используется для технической информации, полезной при разработке
    logger.debug("Проверка работоспособности сервиса")
    
    # Возвращаем JSON-ответ со статусом сервиса
    # jsonify преобразует Python-словарь в JSON-ответ с правильными HTTP-заголовками
    # 200 - HTTP-статус код "OK" (успешный запрос)
    return jsonify({"status": "healthy"}), 200

# Примечания:
# 1. Этот эндпоинт должен быть максимально простым и быстрым, так как:
#    - Он часто вызывается системами мониторинга (Kubernetes, Docker и др.)
#    - Не должен зависеть от других сервисов (это проверка именно этого сервиса)
# 2. В продакшне можно добавить проверки:
#    - Доступности базы данных
#    - Наличия свободного места на диске
#    - Доступности других критичных ресурсов
# 3. Логирование помогает отслеживать частоту проверок и выявлять проблемы